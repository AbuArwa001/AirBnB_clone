                    key = ln[0] + "." + ln[1]
                    value = all_objs[key]
                    # Convert string representation to Python object
                    obj_start = value.index("{")
                    obj_end = value.rindex("}") + 1
                    obj_str = value[obj_start:obj_end]
                    obj = eval(obj_str)
                    # Modify the object
                    setattr(obj, attr_name, attr_value)
                    # Serialize the modified object back to string
                    new_value = value[:obj_start] + str(obj) + value[obj_end:]
                    # Update the data with the new value
                    all_objs[key] = new_value
                    # Serialize the updated data back to JSON
                    updated_data = json.dumps(all_objs, indent=4)
                    print(updated_data)

                    datetime_pattern = r"datetime\.datetime\((\d{4}), (\d{1,2}), (\d{1,2}), (\d{1,2}), (\d{1,2}), (\d{1,2}), (\d{1,6})\)"

# Function to parse datetime string into a datetime object
def parse_datetime(datetime_str):
    match = re.match(datetime_pattern, datetime_str)
    if match:
        year, month, day, hour, minute, second, microsecond = map(int, match.groups())
        return datetime(year, month, day, hour, minute, second, microsecond)
    else:
        return None

# Load JSON string into a Python dictionary
data_dict = json.loads(json_str)

# Convert datetime strings to datetime objects
for key, value in data_dict.items():
    if isinstance(value, str) and value.startswith("datetime.datetime"):
        data_dict[key] = parse_datetime(value)